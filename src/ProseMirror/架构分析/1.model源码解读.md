# 1. model 源码解读

本系列将沿着 ProseMirror 中的流程，来分析 ProseMirror 的架构。

## `OrderedMap`: 持久化数据存储

在 ProseMirror 中，为了方便的处理数据，定义了一套名为 `OrderedMap` 的持久化存储结构。

具体可见：[OrderedMap](../../OrderedMap/README.md).

简单起见，可以理解为 `OrderedMap` 为一组 immutable 映射，其形式为数组： `[key1, value1, key2, value2, ...]`.

## 定义最基本的 Node

首先，定义最基本的几个节点：

```js
// nodes
/** docNodeSpec */
const doc = {
 content: 'block+'
};
/** paragraphNodeSpec */
const paragraph = {
 group: 'block',
 content: 'inline*',
 parseDOM: [{
  tag: 'p'
 }],
 toDOM: () => ['p', 0]
}
/** textNodeSpec */
const text = {
 group: 'inline',
 inline: true
}

// marks
/** emMarkSpec */
const em = {
 parseDOM: [{tag: "i"}, {tag: "em"}, {style: "font-style=italic"}],
 toDOM() { return emDOM }
},

const nodes = { doc, paragraph, text };
const marks = { em }
const topNode = 'doc';

/** schema 用于定义文档模型的结构 */ 
const schema = new Schema({
 nodes,
 marks,
 topNode
})
```

下面，我们来关注 `new Schema(spec)` 中发生了什么：

```js
class Schema {
  //! 为方便观看，与源代码有一些出入
  constructor(spec) {
    /// 1. 将 `spec.nodes` 和 `spec.marks` 传入到 `this.spec` 并转化为 `OrderedMap` 结构。
    // `OrderedMap` 可见说明 1.
    this.spec = {}
    for (let prop in spec) this.spec[prop] = spec[prop]
    this.spec.nodes = OrderedMap.from(spec.nodes)
    this.spec.marks = OrderedMap.from(spec.marks)

    // 2. NodeType.compile 与 MarkType.compile 中均调用了相应的构造函数，即
    //    将 this.spec.nodes: OrderedMap 生成为 nodes: NodeType[], 
    //      同时：约束了 `topNode` 和 `text` 两个 NodeType 必须存在
    //    将 this.spec.nodes: OrderedMap 生成为 marks: MarkType[].
    // 关于 NodeType 与 MarkType 类型可见说明 2.
    this.nodes = NodeType.compile(this.spec.nodes, this)
    this.marks = MarkType.compile(this.spec.marks, this)

    let contentExprCache = Object.create(null)
    // 3. 处理 nodes
    for (let prop in this.nodes) {
      // 保证 nodes 和 marks 中所有数据的 name 不会冲突
      if (prop in this.marks) {
        throw new RangeError(prop + " can not be both a node and a mark")
      }
      // 拿出当前的 NodeType
      let type = this.nodes[prop]
      // 可查看 https://github.com/ProseMirror/prosemirror-model/blob/5ff774fa853dd63ecf30e42ff487b111b3c1c5fd/src/schema.js#L323
      // 例如，对于 'doc' 而言，其 content 为 'block+'
      let contentExpr = type.spec.content || ""
      let markExpr = type.spec.marks
      // contentMatch 是负责解析 content 的模块，
      // 例如 `doc` 的 `content` 为 `block+`, 且由于输入时满足 `group: block` 下一个为 node
      // 因此 `doc.contentMatch.next` 为 `paragraph`
      type.contentMatch = contentExprCache[contentExpr] ||
        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))
      type.inlineContent = type.contentMatch.inlineContent
      type.markSet = markExpr == "_" ? null :
        markExpr ? gatherMarks(this, markExpr.split(" ")) :
        markExpr == "" || !type.inlineContent ? [] : null
    }
    // 4. 处理 marks
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "))
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this)
    this.markFromJSON = this.markFromJSON.bind(this)

    // :: NodeType
    // The type of the [default top node](#model.SchemaSpec.topNode)
    // for this schema.
    this.topNodeType = this.nodes[this.spec.topNode || "doc"]

    // :: Object
    // An object for storing whatever values modules may want to
    // compute and cache per schema. (If you want to store something
    // in it, try to use property names unlikely to clash.)
    this.cached = Object.create(null)
    this.cached.wrappings = Object.create(null)
  }
}

```

说明部分：

1. `OrderedMap` 可以参考[该博客](../../OrderedMap/README.md)。
2. `NodeType` 可见 [代码](https://github.com/ProseMirror/prosemirror-model/blob/5ff774fa853dd63ecf30e42ff487b111b3c1c5fd/src/schema.js#L46)， `MarkType` 可见 [代码](https://github.com/ProseMirror/prosemirror-model/blob/5ff774fa853dd63ecf30e42ff487b111b3c1c5fd/src/schema.js#L237)
